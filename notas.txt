9/18/21          alexistercero55@gmail.com
Alexis Tercero: https://github.com/AlexisTercero55

En este repositorio se alojan las practicas OpenGL de la clase de
Graficaci√≥n por Computadora Grupo:1752-Vargas Castro Daniel (UNAM/MAC).

Mensage de commit: TRANSFORMACIONES AFINES TEORIA.

OpenGL: version 2.1

Caso: GENERACION DE PRIMITIVAS GEOMETRICAS 3D CON OPENGL Y GLUT/FREEGLUT.

Visual Studio Code @\.vscode:
    task.json: Define una tarea de compilacion que se activa con ctrl + shift + b
               ademas manda los binarios a una carpeta especial llamada 'ejecutables'
               que sera ignorada por git mediante .gitignore

               ADVERTENCIAS: En el remoto no se incluye la carpeta 'ejecutables'
                             usted debera crearla para evitar errores en la tarea de compilacion 
                             task.json @ ln: 12
                             o en su defecto modificar el script a sus necesidades.
    
    launch.json: Define la tarea de debugging que se activa con f5.

ARCHIVOS:
    **
    clase.c     Codigo generado a partir de la clase.
    profe.c     CODIGO DE MUESTRA PUBLICADO POR EL PROFESOR Vargas Castro Daniel.

///////////////////////////////////////////////////////////////////////////////////////////////////
9/7/21
-------------------------------------------------------------------------------------
                NOTAS PERSONALES
-------------------------------------------------------------------------------------

Writing an OpenGL Application:
    ENTORNO DE OPENGL EN C/C++
        If you are using C/C++, then you must first set up a build environment 
        (Visual Studio project, GNU makefile, CMake file, etc) that can link to OpenGL.

        Under Windows, you need to statically link to a library called OpenGL32.lib 
        (note that you still link to OpenGL32.lib if you're building a 64-bit executable. 
        The "32" part is meaningless). Visual Studio, and most Windows compilers, 
        come with this library.

    Initialization
        Before you can actually use OpenGL in a program, 
        you must first initialize it. Because OpenGL is platform-independent, 
        there is not a standard way to initialize OpenGL; 
        each platform handles it differently. 
        Non-C/C++ language bindings can also handle these differently.

        There are two phases of OpenGL initialization. 
            The first phase is the creation of an OpenGL Context; 
            the second phase is to load all of the necessary functions to use OpenGL. 
            Some non-C/C++ language bindings merge these into one.
        
        OpenGL Context Creation:
            An OpenGL context represents all of OpenGL. 
            Creating one is very platform-specific, as well as language-binding specific.

    REFERENCIA: https://www.khronos.org/opengl/wiki/Getting_Started (REPASO OBLIGADO)

///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 8/26/21 2D Graficaci√≥n por Computadora con OpenGL    
-------------------------------------------------------------------------------------
                GENERACI√ìN DE PUNTOS, L√çNEAS Y POL√çGONOS
              TEOR√çA Y APLICACI√ìN CON PRIMITIVAS DE OPENGL
-------------------------------------------------------------------------------------

TIPOS DE DATO DE OpenGL:
    Para mayor portabilidad, OpenGL define sus propios tipos de dato, 
    que en general son compatibles con los tipos est√°ndar del lenguaje C.

    GLboolean   1   GL_TRUE, GL_FALSE
    GLint       32  entero con signo en complemento a 2
    GLfloat     32  IEEE-754
    GLdouble    64  IEEE-754
    GLenum      32  ENUMERACIONES

    https://www.khronos.org/opengl/wiki/OpenGL_Type

ENTORNO DE DIBUJO EN OPENGL:
    glBegin y glEnd delimitan los v√©rtices que definen una primitiva 
    o un grupo de primitivas similares.

    INDICAR A OpenGL EL INICIO DE UN DIBUJO CON PRIMITIVAS:
        void glBeging(GLenum mode);

        glBegin acepta un √∫nico argumento que especifica en cu√°l de las diez formas 
        se interpretan los v√©rtices.

        GLenum mode:
            Especifica la primitiva o primitivas que se crear√°n a partir de los v√©rtices 
            presentados entre glBegin y el glEnd. EXISTEN 10 MODOS (CONSTANTES SIMBOLICAS)
            
            Tomando 'n' como un n√∫mero entero que comienza en 1 y 
            'N' como el n√∫mero total de v√©rtices especificados, 
            las interpretaciones son las siguientes.
            mode :
                GL_POINTS           :   Trata cada v√©rtice como un solo punto. 
                                        El v√©rtice n define el punto n. Se dibujan N puntos.
                GL_LINES            :   Trata cada par de v√©rtices como un segmento de l√≠nea independiente. 
                                        Los v√©rtices 2n-1 y 2n definen la l√≠nea n. Se dibujan N/2 l√≠neas. 
                GL_LINE_STRIP       :   Dibuja un grupo conectado de segmentos de l√≠nea 
                                        desde el primer v√©rtice hasta el √∫ltimo. 
                                        Los v√©rtices n y n + 1 definen la l√≠nea n. Se dibujan N - 1 l√≠neas.
                GL_LINE_LOOP        :   Dibuja un grupo conectado de segmentos de l√≠nea desde el primer v√©rtice hasta el √∫ltimo 
                                        y luego de regreso al primero. Los v√©rtices n y n + 1 definen la l√≠nea n.
                                        Sin embargo, la √∫ltima l√≠nea est√° definida por los v√©rtices N y 1. Se dibujan N l√≠neas.
                GL_TRIANGLES        :   Trata cada triplete de v√©rtices como un tri√°ngulo independiente. 
                                        Los v√©rtices 3n-2, 3n-1 y 3n definen el tri√°ngulo n. Se dibujan N/3 tri√°ngulos.
                GL_TRIANGLE_STRIP   :   Dibuja un grupo de tri√°ngulos conectados. Se define un tri√°ngulo para cada v√©rtice 
                                        presentado despu√©s de los dos primeros v√©rtices. 
                                        Para n impar, los v√©rtices n, n + 1 y n + 2 definen el tri√°ngulo n. 
                                        Para n pares, los v√©rtices n + 1, n y n + 2 definen el tri√°ngulo n. 
                                        Se dibujan N - 2 tri√°ngulos.
                GL_TRIANGLE_FAN     :   Dibuja un grupo de tri√°ngulos conectados. Se define un tri√°ngulo para cada v√©rtice 
                                        presentado despu√©s de los dos primeros v√©rtices. Los v√©rtices 1, n + 1 y n + 2 
                                        definen el tri√°ngulo n. Se dibujan N - 2 tri√°ngulos.
                GL_QUADS            :   Trata cada grupo de cuatro v√©rtices como un cuadril√°tero independiente. 
                                        Los v√©rtices 4 ‚Å¢ n - 3, 4 ‚Å¢ n - 2, 4 ‚Å¢ n - 1 y 4 ‚Å¢ n definen el cuadril√°tero n. 
                                        Se dibujan N 4 cuadril√°teros.
                GL_QUAD_STRIP       :   Dibuja un grupo conectado de cuadril√°teros. Se define un cuadril√°tero para cada par de v√©rtices 
                                        presentado despu√©s del primer par. Los v√©rtices 2 ‚Å¢ n - 1, 2 ‚Å¢ n, 2 ‚Å¢ n + 2 y 2 ‚Å¢ n + 1 
                                        definen el cuadril√°tero n. Se dibujan N 2 - 1 cuadril√°teros. 
                                        Tenga en cuenta que el orden en el que se usan los v√©rtices para construir 
                                        un cuadril√°tero a partir de datos de franjas es diferente del que se usa con datos independientes.
                GL_POLYGON          :   Dibuja un √∫nico pol√≠gono convexo. Los v√©rtices del 1 al N definen este pol√≠gono.

            Las l√≠neas, tri√°ngulos, cuadril√°teros y pol√≠gonos que no se especifican por completo 
            no se dibujan

            La especificaci√≥n m√≠nima de v√©rtices para cada primitiva es la siguiente: 
                1 para un punto, 
                2 para una l√≠nea, 
                3 para un tri√°ngulo, 
                4 para un cuadril√°tero,
                3 para un pol√≠gono. 
            Los modos que requieren cierto m√∫ltiplo de v√©rtices son: 
                GL_LINES (2), 
                GL_TRIANGLES (3), 
                GL_QUADS (4) y 
                GL_QUAD_STRIP (2).

    INDICAR A OpenGL EL FINAL DE UN DIBUJO CON PRIMITIVAS:
        void glEnd();
    
    INDICAR A OpenGL QUE REALICE LOS DIBUJOS PREVIAMENTE DEFINIDOS ENTRE 
    LAS FUNCIONES glBegin y glEnd, PUEDEN SER VARIOS DIBUJOS:
        void glFinish(void);
    
    BORRAR EL DUBUJO ANTERIOR   <<glClear>>:
        Borrar b√∫feres a valores preestablecidos.

        void glClear(GLbitfield mask);

        GLbitfield mask (indican los b√∫feres que se borrar√°n):
            GL_COLOR_BUFFER_BIT     :   Indica los b√∫feres actualmente habilitados para la escritura en color.
            GL_DEPTH_BUFFER_BIT     :   Indica el b√∫fer de profundidad.
            GL_ACCUM_BUFFER_BIT     :   Indica el b√∫fer de acumulaci√≥n.
            GL_STENCIL_BUFFER_BIT   :   Indica el b√∫fer de la plantilla.
        Si no hay un b√∫fer, entonces un glClear dirigido a ese b√∫fer no tiene ning√∫n efecto.

        EJ: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClear.xml (LEYENDO REPASO NECESARIO)
    
    ADVERTENCIAS:
        Solo se puede usar un subconjunto de comandos GL entre glBegin y glEnd. 
        Los comandos son: 
            glVertex, 
            glColor, 
            glSecondaryColor, 
            glIndex, 
            glNormal, 
            glFogCoord, 
            glTexCoord, 
            glMultiTexCoord, 
            glVertexAttrib, 
            glEvalCoord, 
            glEvalPoint, 
            glArrayElement, 
            glMaterial y 
            glEdgeFlag. 
        Adem√°s, es aceptable usar glCallList o glCallLists para ejecutar listas de visualizaci√≥n 
        que incluyen solo los comandos anteriores. Si se ejecuta cualquier otro comando GL entre glBegin y glEnd, 
        se establece el indicador de error y se ignora el comando.

        OpenGL no tiene forma de saber cu√°ndo debe redibujar 
        los contenidos en la ventana. Para hacer esto, se debe solicitar a GLUT, 
        que ejecute nuevamente la funci√≥n glutDisplayFunc mediante la funci√≥n:
            void glutPostRedisplay(void);
        NOTA: ESTO LO HACE EL MANEJADOR DE VENTANS, EN ESTE CASO FREEGLUT.
    
    IMPLEMTACION DE ENTORNO DE DIBUJO OpenGL EN C:
        glBegin(GLenum mode); //DEFINE UN DIBUJO
            /*ponga aqui sus primitivas OpenGL
              No hay l√≠mite para el n√∫mero de v√©rtices que se pueden definir entre glBegin y glEnd.
            */
        glEnd();// TERMINA EL DIBUJO
        glFinish();//ACCION DIBUJAR (PARA OpenGL)

    REFERENCIA:
        https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml (leido hasta errores)

    Si no se define una c√°mara, cada coordenada puede estar en un rango de [‚àí1, 1].

Colores en primitivas <<glColor>>:
    glColor establece un nuevo color RGBA de cuatro valores.

    Cambiar el color (EXISTEN MAS FUNCIONES):
        void glColor3f(GLfloat red, GLfloat green, GLfloat blue); [0,1]
        void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);

    PRINCIPALES VARIANTES DE glColor:
        glColor3 : RECIBEN 3 PARAMETROS (RGB)
        glColor3 : RECIBEN 4 (RGBA)

        OTRAS QUE RECIBEN EL PUNTERO A UN ARREGLO CON LOS VALORES:
            void glColor4fv(const GLfloat * v);
    
    Associated Gets
    glGet with argument GL_CURRENT_COLOR
    glGet with argument GL_RGBA_MODE

    REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml (LEYENDO, REPASO OPCIONAL)

ESTADOS DE OpenGL:  OpenGL FUNCIONA COMO UNA MAQUINA DE ESTADOS. 
    Pasar puntero de funcion con instrucciones de dibujo:
        The new display callback function.

        DEFINICION:
            void glutDisplayFunc(void (*func)(void));

            Establece la devoluci√≥n de llamada de pantalla para la ventana actual.
    
        DESCRIPCION:
            Cuando GLUT determina que es necesario volver a visualizar el plano normal 
            de la ventana, se llama a la devoluci√≥n de llamada de visualizaci√≥n de la ventana.

            Antes de la devoluci√≥n de llamada, la ventana actual se establece en la ventana 
            que debe volver a mostrarse y 
            (si no se registra ninguna devoluci√≥n de llamada de visualizaci√≥n superpuesta), 
            la capa en uso se establece en el plano normal.

        REFERENCIA: https://www.opengl.org/resources/libraries/glut/spec3/node46.html (LEYENDO : REPASO NESESARIO)

    Indicar que dibuje a OpenGL glFinish:
        glFinish no regresa hasta que se completan los efectos 
        de todos los comandos GL previamente llamados. 
        Dichos efectos incluyen todos los cambios en el estado GL, 
        todos los cambios en el estado de la conexi√≥n y 
        todos los cambios en el contenido del b√∫fer de tramas (frame buffer).

        DEFINICION:
            void glFinish(	void);
        
        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml

    Indicar al sistema que despliegue.
        Marca la ventana actual que necesita volver a mostrarse.

        DEFINICION:
            void glutPostRedisplay(void);
        
        DESCRIPCION:
            Marque el plano normal de la ventana actual que necesita volver a mostrarse.
            En la siguiente iteraci√≥n a trav√©s de glutMainLoop, se llamar√° a la devoluci√≥n 
            de llamada de visualizaci√≥n de la ventana para volver a visualizar el plano 
            normal de la ventana.

            Varias llamadas a glutPostRedisplay antes de la pr√≥xima oportunidad de devoluci√≥n 
            de llamada de pantalla genera solo una √∫nica devoluci√≥n de llamada de visualizaci√≥n. 
            glutPostRedisplay se puede llamar dentro de la pantalla de una ventana o la devoluci√≥n 
            de llamada de la pantalla superpuesta para volver a marcar esa ventana para volver a 
            mostrarla.
        
        REFERENCIA: https://www.opengl.org/resources/libraries/glut/spec3/node20.html

OBJETOS 2D BASICOS (PRIMITIVAS):
    POLIGONO
    ARISTA
    VERTICE

VERTICES 2D EN OpenGL:
    DEFINICION:
        void glvertex2f(GLfloat, GLfloat);
        Ej: glVertex2f(-0.5, 0.3);

    si no se define una camara, cada coordenada debe estar en [-1,1].

    GLenum mode : GL_POINTS

    Especificar el di√°metro de los puntos rasterizados:
        void glPointSize(GLfloat size); // DEFAULT size = 1
    
    IMPLEMENTACION EN C:
        glBegin(GL_POINTS);
            glVertex2f(x1, y1);
            glVertex2f(x2, y2);
            //...
            glVertex2f(xn, yn);
        glEnd();

LINEAS EN OpenGL:   VOID glBeging(GLenum mode);
    GLenum mode
        GL_LINES
        GL_LINE_STRIP
        GL_LINE_LOOP

POLIGONOS EN OpenGL:    VOID glBeging(GLenum mode);
    CONVENCION DE DEFINICION DE VERTICES EN POLIGONOS (CCW)
    CCW : COUNTER CLOCK WISE

    GLenum mode 
        GL_TRIANGLES
        GL_TRIANGLE_STRIP
        GL_TRIANGLE_FAN
        GL_QUADS
        GL_QUAD_STRIP
        GL_POLYGON  :   POLIGONO CONVEXO
///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 8/31/21 Graficaci√≥n por Computadora con OpenGL 
**DOCUMENTAR EL PIPELINE DE RENDERIZADO Y LAS PROYECCIONES
**DOCUMENTAR glViewport
**VOLUMEN DE RENDERIZADO
---------------------------------------------------------------------------------
            PERCEPCI√ìN DE PROFUNDIDAD EN UNA IMAGEN PLANA
    IMPLEMENTACI√ìN MEDIANTE C√ÅMARAS, LUCES Y BUFFERS EN GLUT/FREEGLUT
---------------------------------------------------------------------------------

PERCEPCI√ìN DE PROFUNDIDAD:
    Los efectos de profundidad se realizan en los procesos de 
    ‚ÄúIluminaci√≥n‚Äù y ‚ÄúProyecci√≥n‚Äù en el paso de ‚ÄúGeometr√≠a‚Äù del 
    pipeline de renderizado.

    SE NECESITA CONFIGURAR UNA PROYECCION EN PERSPECTIVA
    En la proyecci√≥n en perspectiva, el volumen de recorte es una
    pir√°mide trunca (frustum), por lo que los objetos m√°s lejanos a la
    c√°mara se ven m√°s peque√±os en la proyecci√≥n al plano.

PROYECIONES: 
    Por defecto, OpenGL tiene configurada una matriz para hacer cambios directamente 
    en la escena 3D (mundo), por lo que antes de empezar a configurar la c√°mara, 
    es necesario avisarle que se har√°n cambios a la matriz de proyecci√≥n y cargarle 
    una matriz identidad inicial con las funciones:

    MATRIZ DE PROYECCION:
        void glMatrixMode(GLenum mode);
            
            Especificar qu√© matriz es la matriz actual.

            PARAMETROS: (GLenum mode)
                Especifica qu√© pila de matrices es el destino de las operaciones 
                de matriz posteriores. 
                Se aceptan tres valores
                GLenum mode :
                    GL_MODELVIEW, 
                    GL_PROJECTION,
                    GL_TEXTURE. 
                El valor inicial es GL_MODELVIEW. Adem√°s, si se admite la extensi√≥n 
                ARB_imaging, tambi√©n se acepta GL_COLOR.
            
            DESCRIPCION:
                glMatrixMode: Establece el modo de matriz actual. 
                              modo puede asumir uno de cuatro valores:

                GL_MODELVIEW
                Aplica las operaciones de matriz subsiguientes a la pila de matrices de modelview.
                    pila de matrices de modelview:
                        MATRIZ DE MODELO : COORDENADAS LOCALES A COORDENADAS DE MUNDO.
                        MATRIZ DE VISTA : ESPACIO A CAMARA

                GL_PROJECTION
                Aplica operaciones de matriz posteriores a la pila de matrices de proyecci√≥n.

                GL_TEXTURE
                Aplica las operaciones de matriz subsiguientes a la pila de matriz de textura.

                GL_COLOR
                Aplica las operaciones de matriz subsiguientes a la pila de matrices de colores.

                Para averiguar qu√© pila de matrices es actualmente el objetivo de todas 
                las operaciones de matrices, llame a glGet con el argumento GL_MATRIX_MODE. 
                El valor inicial es GL_MODELVIEW.
                    glGet(GL_MATRIX_MODE);
                
                NOTAS ADICIONALES DE LA PILA DE MATRICES (O VALORES DE GLenum mode):
                    The model, view and projection matrices are three separate matrices. 
                    Model maps from an object's local coordinate space into world space, 
                    view from world space to camera space, projection from camera to screen.
                    
                    If you compose all three, you can use the one result to map all the way 
                    from object space to screen space, making you able to work out what you 
                    need to pass on to the next stage of a programmable pipeline from the 
                    incoming vertex positions.
                    
                    In the fixed functionality pipelines of old, you'd apply model and view together, 
                    then work out lighting using another result derived from them (with some fixes so 
                    that e.g. normals are still unit length even if you've applied some scaling to the 
                    object), then apply projection. You can see that reflected in OpenGL, which never 
                    separates the model and view matrices ‚Äî keeping them as a single modelview matrix 
                    stack. You therefore also sometimes see that reflected in shaders.
                    
                    So: the composed model view projection matrix is often used by shaders to map from 
                    the vertices you loaded for each model to the screen. It's not required, there are 
                    lots of ways of achieving the same thing, it's just usual because it allows all 
                    possible linear transforms. Because of that, a lesser composed version of it was 
                    also the norm in ye olde fixed pipeline world.

                    REFERENCIA: https://stackoverflow.com/questions/5550620/the-purpose-of-model-view-projection-matrix

            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml (repaso obligado)

        void glLoadIdentity(void);

            Reemplazar la matriz actual con la matriz de identidad.

            glLoadIdentity replaces the current matrix with the identity matrix. 
            It is semantically equivalent to calling glLoadMatrix with the identity matrix
                1 0 0 0 
                0 1 0 0 
                0 0 1 0 
                0 0 0 1
            but in some cases it is more efficient.

            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml (REPASO OBLIGADO)

    ORTOGONAL:
        ES LA PROYECCION POR DEFECTO.
        SU VOLUMEN DE RECORTE ES UNA CAJA QUE VA  DE -1 A 1.

        CONFIGURACION:
            Multiplicar la matriz actual con una matriz ortogr√°fica.

            void glOrtho(   GLdouble left,
                            GLdouble right,
                            GLdouble bottom,
                            GLdouble top,
                            GLdouble nearVal,
                            GLdouble farVal);
            
            PARAMETROS (VOLUMEN DE RECORTE):
                left, right:
                    Specify the coordinates for the left and right 
                    vertical clipping planes.

                bottom, top
                    Specify the coordinates for the bottom and top 
                    horizontal clipping planes.

                nearVal, farVal
                    Specify the distances to the nearer and farther 
                    depth clipping planes. These values are negative 
                    if the plane is to be behind the viewer.
        
        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml (REPASO OBLIGATORIO)

    PERSPECTIVA:
        Multiplicar la matriz actual por una matriz de perspectiva

        void glFrustum(	GLdouble left,
                        GLdouble right,
                        GLdouble bottom,
                        GLdouble top,
                        GLdouble nearVal,
                        GLdouble farVal);
        
            PARAMETROS (VOLUMEN DE RECORTE):
                left, right:
                Specify the coordinates for the left and right 
                vertical clipping planes.

                bottom, top
                Specify the coordinates for the bottom and top 
                horizontal clipping planes.

                nearVal, farVal
                Specify the distances to the near and far depth clipping planes. 
                Both distances must be positive.

            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml (REPASO OBLIGATORIO)

        ADVERTENCIAS: 
            ESPECIFICAR EL VOLUMEN DE RECORTE ES COMPLICADO DADA LA NATURALEZA
            DE SU FORMA (UNA PIRAMIDE TRUNCA), RESULTA DIFICIAL SABER CUAL SERA EL
            RESULTADO AL ESPECIFICAR VALORES A glFrustum.

        USO DE GLU (OPENGL UTILITY) PARA CONFIGURAR LA PROYECCION EN PERSPECTIVA
        DE UNA MANERA MAS SENCILLA.
        CONFIGURACION:
            Configurar una matriz de proyecci√≥n en perspectiva.

            void gluPerspective(GLdouble fovy,
                                GLdouble aspect,
                                GLdouble zNear,
                                GLdouble zFar);

            PARAMETROS:
                fovy
                Specifies the field of view angle, in degrees, in the y direction.

                aspect
                Specifies the aspect ratio that determines the field of view in the 
                x direction. The aspect ratio is the ratio of x (width) to y (height).

                    Resoluci√≥n pixeles (ancho √ó alto)   aspect  Uso
                    640√ó480 (SD), 800√ó600,              1.33    Est√°ndar de televisi√≥n SD y 
                    1440√ó1080, 1920√ó1440                (4:3)   algunos monitores ‚Äúcuadrados‚Äù
                    
                    1280√ó720 (HD), 1366√ó768,            1.77    Est√°ndar de televisi√≥n actual y
                    1920√ó1080 (FHD), 3840√ó2160 (4K)     (16:9)  algunos celulares.
                    
                zNear
                Specifies the distance from the viewer to the near clipping plane 
                (always positive).

                zFar
                Specifies the distance from the viewer to the far clipping plane 
                (always positive).
            
            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml (REPASO OBLIGATORIO)

    ADVERTENCIAS:
        SOLO SE LLAMAN LAS FUNCIONES DE PROYECCION CADA CAMBIO DE CAMARA.
            
CAMARA:
    POSICIONAMIENTO CON GLU:
        Definir una transformaci√≥n de visualizaci√≥n.

        void gluLookAt(	GLdouble eyeX,
                        GLdouble eyeY,
                        GLdouble eyeZ,
                        GLdouble centerX,
                        GLdouble centerY,
                        GLdouble centerZ,
                        GLdouble upX,
                        GLdouble upY,
                        GLdouble upZ);
        
        PARAMETROS: (EN COORDENADAS DE MUNDO)
            eyeX, eyeY, eyeZ
            Specifies the position of the eye point.

            centerX, centerY, centerZ
            Specifies the position of the reference point.

            upX, upY, upZ
            Specifies the direction of the up vector.
        
        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml (REPASO OBLIGATORIO)

ILUMINACION:
    ACTIVAR ILUMINACION:
        habilitar o deshabilitar las capacidades de GL del lado del servidor.

        void glEnable(GLenum cap);

            PARAMETROS: cap
                Especifica una constante simb√≥lica que indica una capacidad GL.

                GL_LIGHTING     //ILUMINACION GENERAL
                    EL VALOR NECESARIO PARA ACTIVAR LA ILUMINACION.

                GL_LIGHTi       //TIPO ESPECIFICO DE ILUMINACION
                    Si est√° habilitado, incluya la luz i en la evaluaci√≥n de 
                    la ecuaci√≥n de iluminaci√≥n. Consulte glLightModel y glLight.

                    i puede ser cualquier n√∫mero del 0 al 7, correspondiente al 
                    √≠ndice de la luz.
            
            DESCRIPCION:
                glEnable y glDisable habilitan y deshabilitan varias capacidades.
                Utilice glIsEnabled o glGet para determinar la configuraci√≥n actual 
                de cualquier capacidad. El valor inicial para cada capacidad con la 
                excepci√≥n de GL_DITHER y GL_MULTISAMPLE es GL_FALSE.

            REFERENCIA: (REPASO OBLIGADO)

BUFFERS: EFICIENCIA EN RENDERIZADO
    DE COLOR:   ALMACENA LOS COLOERS DE CADA PIXEL.
    DE COLOR DOBLE: FRONTBUFFER, BACKBUFFER.
    DE PROFUNDIDAD: Z-BUFFER CONTIENE LA PROFUNDIDAD DE CADA OBJETO EN LA ESCENA
                    lO QUE NOS PERMITE SABER QUE OBJETOS SE DIBUJAN SOBRE OTROS
                    (ELEGIR QUE RENDERIZAR).

CONFIGURACION DE UNA CAMARA EN PERSPECTIVA CON GLU (#include <GL/glu.h>):
    La siguiente funci√≥n configura una proyecci√≥n en perspectiva con un √°ngulo de apertura de 45¬∞, 
    una relaci√≥n de aspecto calculada de acuerdo al tama√±o de la ventana y 
    planos de corte cercano y lejano en 0.1 y 1000, respectivamente. 
    Posteriormente, se coloca una c√°mara en las coordenadas (0, 0, 10),
    viendo hacia el centro del mundo (0, 0, 0) y sin rotaci√≥n (up = (0, 1, 0)).

    void camara(void)
    {
        float ancho = GLUT_WINDOW_WIDTH;
        float alto = GLUT_WINDOW_HEIGHT;
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(45, ancho/alto, 0.1, 1000);
        gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
    }

    Solo se configura la camara en cada cambio de camara

CONFIGURACION DE BUFFERS DE GLUT/FREEGLUT:

    INICIALIZAR UNA VENTANA CON BUFFERS
    void glutInitDisplayMode(unsigned int mode);

        establece el modo de visualizaci√≥n inicial.

        unsigned int mode:
            Modo de visualizaci√≥n, normalmente la operaci√≥n OR bit a bit 
            de las m√°scaras de bits del modo de visualizaci√≥n GLUT. 
            Consulte los valores a continuaci√≥n

            GLUT_RGBA
            GLUT_DOUBLE
            GLUT_DEPTH
    
    REFERENCIA: https://www.opengl.org/resources/libraries/glut/spec3/node12.html (REPASO OBLIGADO**)

habilitar o deshabilitar las capacidades de GL del lado del servidor.

    void glEnable(GLenum cap);

        PARAMETROS: cap
            Especifica una constante simb√≥lica que indica una capacidad GL.

            EL VALOR NECESARIO PARA ACTIVAR LA ILUMINACION ES: GL_LIGHTING.
        
        DESCRIPCION:
            glEnable y glDisable habilitan y deshabilitan varias capacidades.
            Utilice glIsEnabled o glGet para determinar la configuraci√≥n actual 
            de cualquier capacidad. El valor inicial para cada capacidad con la 
            excepci√≥n de GL_DITHER y GL_MULTISAMPLE es GL_FALSE.

        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml (REPASO OBLIGADO)

///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 9/2/21 Graficaci√≥n por Computadora con OpenGL 
**DOCUMENTAR ARCHIVOS .OBJ
---------------------------------------------------------------------------------
                            OBJETOS 3D
             GENERACI√ìN DE MALLAS POLIGONALES CON OPENGL
---------------------------------------------------------------------------------

MALLAS:
    ES UNA COLECCION DE (COMPONENTES DE UNA MALLA) 
        VERTICES
        ARISTAS
        POLIGONOS
    QUE DEFINEN UN POLIEDRO.

    PARA REPRESENTAR UN OBJETO EN 3D SE HACE USO DE LA
    DISCRETIZACION MEDIANTE MALLAS POLIGONALES.

    GEOMETRIA:
        DEFINE COMO SE CONECTAN SUS COMPONENTES ENTRE SI.
        GENERALMENTE SOLO DEFINEN LA SUPERFICIE DE LOS OBJETOS.
    
    TIPOS:
        EN RENDERIZADO : MALLLAS DE TIANGULOS (TRIS).
        EN ANIMACION Y MODELADO 3D : MALLAS DE CUADRILATEROS (QUADS).

        Com√∫nmente se utilizan mallas que combinan tri√°ngulos y cuadril√°teros.

    ADVERTENCIA:
        Por convenci√≥n, un pol√≠gono se define indicando
        sus v√©rtices en sentido contrario a las manecillas
        del reloj (Counter-Clock Wise o CCW), lo cual
        permite definir su cara frontal.

3D EN OPENGL:
    Las primitivas de OpenGL son objetos 1D y 2D que sirven para representar 
    puntos, l√≠neas y pol√≠gonos en un espacio 2D o 3D.

    ESPECIFICAR UN VERTICE (EN COORDENADAS DE MUNDO):
        void glVertex3f(GLfloat x, GLfloat y, GLfloat z);
    
    EJEMP: Definir un plano normal al eje ùë¶ con lados de longitud L
        void plano_xz(GLfloat L) 
        {
            glBegin(GL_QUADS);
                glVertex3f(-L/2, 0, L/2);
                glVertex3f(L/2, 0, L/2);
                glVertex3f(L/2, 0, -L/2);
                glVertex3f(-L/2, 0, -L/2);
            glEnd();
        }

PRIMITIVAS GEOMETRICAS 3D CON GLUT EN MODO SOLIDO Y WIREFRAME:
    CUBO
        void glutSolidCube(GLdouble size);
        void glutWireCube(GLdouble size);
    ESFERA
        void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks);
        void glutWireSphere(GLdouble radius, GLint slices, GLint stacks);
    CONO
        void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
        void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
    TORO
        void glutSolidTorus(GLdouble innerRadius, 
                            GLdouble outerRadius,
                            GLint nsides, 
                            GLint rings);
        void glutWireTorus(GLdouble innerRadius, 
                           GLdouble outerRadius,
                           GLint nsides, 
                           GLint rings);

GLU Models, otras primitivas de Glut:
    GLU provides so called Quadrics objects:
        disk
        partial disk
        sphere
        cylinder
    
    gluCylinder
        Three steps to create a cylinder:
            1. Create a GLU quadric object
                GLUquadricObj *p = gluNewQuadric();
            2. Set to wire frame mode
                gluQuadricDrawStyle(p,GLU__LINE); //o GLU_FILL 
                ADVERTENCIA: **la presentacion no indica p
            3. Derive a cylinder object from p
                gluCylinder(p, base, top, height, slice, stacks);

    REFERENCIA: 
        https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluCylinder.xml
        http://www.csc.villanova.edu/~mdamian/Past/graphicsfa10/notes/HierarchyHand.pdf
        https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluQuadricDrawStyle.xml

DISCRETIZACION DE UNA ESFERA:
    SE DISCRETIZA EN BASE A SUS  PARAMETROS: 
        RADIO
        NUMERO DE PARALELOS  (stacks)
        NUMERO DE MERIDIANOS (slices)
    
    ECUACIONES PARAMETRICAS DE UNA ESFERA
        x_i = (r \cos(\phi_i))\cos\theta_i
        y_i = (r \cos(\phi_i))\sin\theta_i
        x_i = r\sin\theta_i

        \theta_i es el angulo de meridiano y \phi_i el angulo del
        paralelo deseado, discretizados mediante las ecuaciones:
            \theta_i = 2\pi\frac{slice_i}{nSlices}
            \phi = 2\pi\frac{stack_i}{nStacks}  **cambiar a espa√±ol

DISCRETIZACION DE UN CONO:
    SE DISCRETIZA EN BASE A SUS  PARAMETROS:
        ALTURA h
        RADIO r
        NUMERO DE VERTICES QUE FORMAN LA BASE n
    
    Las coordenadas de un vertice en el circulo que forma la base:
        x_i = r\cos\theta_i
        y_i = r\sen\theta_i
        z_i = -\frac{h}{2}

        donde   \theta_i = 2\pi\frac{i}{n}

    EL VERTICE DE CONVERGENCIA DE TODAS LAS CARAS DEL CONO ES (0,0,\frac{h}{2})

DISCRETIZACION DE UN CILINDRO:
    SE DISCRETIZA EN BASE A SUS PARAMETROS:
        ALTURA h
        RADIO r
        CANTIDAD DE VERTICES EN AMBAS BASES
    
    Las coordenadas de un vertice en el circulo que forman las bases:
        x_i = r\cos\theta_i
        y_i = r\sen\theta_i
        z_i = \pm\frac{h}{2}

        donde   \theta_i = 2\pi\frac{i}{n}

DISCRETIZACI√ìN DE UN TOROIDE
    SE DISCRETIZA EN BASE A SUS PARAMETROS:
        RADIO MEOR r
        RADIO MAYOR R
        NUMERO DE ANILLOS n
    
    veritce en su superficie:
        x_i = (R + r\cos\alpha_i)\cos\beta_i
        y_i = (R + r\cos\alpha_i)\sen\beta_i
        z_i = r\sin\alpha_i

///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 9/7/21 Graficaci√≥n por Computadora con OpenGL <<terminar apuntes de presentacion antes del commit>>
**actual commit 
**como sustituyen las operaciones con coordenadas homogeneas a las transformaciones afines?
**https://www.youtube.com/watch?v=WDIkqP4JbkE
---------------------------------------------------------------------------------
                   TRANSFORMACIONES GEOMETRICAS
TRANSFORMACIONES AFINES: TRASLACION, ROTACION, ESCALAMIENTO, SESGO Y REFLEXION
---------------------------------------------------------------------------------

TRANSFORMACIONES:
    DAR SENSACION DE MOVIMIENTO.

    TRANSFORMACION AFIN (ALGEBRA LINEAL):
        Una transformaci√≥n af√≠n en un espacio eucl√≠deo (R^2,R^3) es una transformaci√≥n que 
        preserva:
            la colinealidad, 
            la coplanaridad 
            las razones de las distancias entre puntos a lo largo de una l√≠nea.

        Pragm√°ticamente, consisten en una transformaci√≥n lineal seguida de una traslaci√≥n 
        y se suele representar de la siguiente forma:

            T:X\to AX + B

            Y = AX + B

            donde:
                Y : el punto mapeado en el nuevo conjunto.
                X : el punto original que se desea mapear.
                A : una matriz de transformaci√≥n.
                B : un vector de traslaci√≥n

    CONVENCIONES:
        LOS VERTICES SE ENTINDEN COMO VECTORES COLUMNA.

TRANSFORMACIONES AFINES:
    TRASLACION:
        Y = X + B
    
    ROTACION:
        ES cambio de orientaci√≥n de un cuerpo o un sistema de referencia
        de forma que una l√≠nea, llamada eje de rotaci√≥n, permanece fijo.

        2D:
            R(\theta) = \begin{pmatrix}
                            \cos\theta & -\sin\theta\\
                            \sin\theta & \cos\theta
                        \end{pmatrix}

            DONDE \theta es el √°ngulo en grados en que se desea rotar el plano.
        
        3D: (Es necesario especificar el eje de rotaci√≥n)
            R_x(\theta) = \begin{pmatrix}
                            1 &      0     &    0       \\
                            0 & \cos\theta & -\sin\theta\\
                            0 & \sin\theta & \cos\theta
                          \end{pmatrix}

            R_y(\theta) = \begin{pmatrix}
                            \cos\theta  & 0 & \sin\theta \\
                                0       & 1 &    0       \\
                            -\sin\theta & 0 & \cos\theta
                          \end{pmatrix}
            
            R_z(\theta) = \begin{pmatrix}
                            \cos\theta & -\sin\theta & 0 \\
                            \sin\theta &  \cos\theta & 0 \\
                                0      &        0    & 1
                          \end{pmatrix}
    
    ESCALAMIENTO:
        Es el incremento o disminuci√≥n del tama√±o de un cuerpo.

        2D:
            S = \begin{pmatrix}
                    S_x &  0\\
                     0  & S_y
                \end{pmatrix}
        
        3D:
            S = \begin{pmatrix}
                    S_x &  0  &  0  \\
                     0  & S_y &  0  \\
                     0  &  0  & S_z
                \end{pmatrix}

    REFLEXION:
        2D:
            La reflexi√≥n en 2D desplaza cada punto de un cuerpo usando una l√≠nea de reflexi√≥n,
            tal que cada nuevo punto est√° a la misma distancia de dicha l√≠nea 
            con respecto al punto original.

            La matriz de reflexi√≥n sobre una l√≠nea arbitraria en la forma ùë¶ = ùëöùë• es:

                Ref = \frac{1}{1 + m^2}\begin{pmatrix}
                                            1 - m^2 & 2m  \\
                                              2m    & m^2
                                       \end{pmatrix}
            
            De lo anterior se deduce que la reflexi√≥n sobre los ejes x y y,
            se representan mediante las siguientes matrices:

                Ref_x = \begin{pmatrix}
                            1 &  0 \\
                            0 & -1
                        \end{pmatrix}
                
                Ref_y = \begin{pmatrix}
                            -1 & 0 \\
                             0 & 1
                        \end{pmatrix}
        
        3D:
            La reflexi√≥n en 3D desplaza cada punto de un cuerpo usando un plano de reflexi√≥n,
            tal que cada nuevo punto est√° a la misma distancia de dicho plano 
            con respecto al punto original.

            La matriz de reflexi√≥n para cualquier plano que pasa por el origen,
            con una normal unitaria ùëÅ = (ùëé, ùëè, ùëê) es:

                Ref = \begin{pmatrix}
                        1 - 2a^2 &  -2ab    &  -2ac \\
                          -2ab   & 1 - 2b^2 &  -2bc \\
                          -2ac   &  -2bc    & 1 - 2c^2
                      \end{pmatrix}
            
            De lo anterior se deduce que la reflexi√≥n sobre los planos xy, yz y el xz, 
            se representan mediante las siguientes matrices.

                Ref_xy = \begin{pmatrix}
                           1 & 0 & 0 \\
                           0 & 1 & 0 \\
                           0 & 0 & -1
                         \end{pmatrix}
                
                Ref_yz = \begin{pmatrix}
                           -1 & 0 & 0 \\
                           0 & 1 & 0 \\
                           0 & 0 & 1
                         \end{pmatrix}
                
                Ref_xz = \begin{pmatrix}
                           1 & 0 & 0 \\
                           0 & -1 & 0 \\
                           0 &  0& 1
                         \end{pmatrix}

COMPOSICI√ìN DE TRANSFORMACIONES AFINES:
    Es la aplicaci√≥n de una serie de transformaciones una detr√°s de otra. 
    Esto se suele representar mediante ecuaciones del tipo:

        Y = A_1A_2\dots A_n + B_1 + \dots + B_n

        ¬°Recuerda que la multiplicaci√≥n de matrices no es conmutativa!

COORDENADAS HOMOGENEAS (GEOMETRIA PROYECTIVA):
    Este sistema de coordenadas permite ampliar un espacio
    eucl√≠deo de dimensi√≥n ùëõ a un espacio proyectivo de dimensi√≥n ùëõ + 1. 
        
        T: R^n + R^(n+1)

        Esta nueva dimensi√≥n representa un punto en el infinito
        donde las l√≠nea paralelas se intersecan, dando una ilusi√≥n de perspectiva.
    
    Debido a sus propiedades matem√°ticas, las transformaciones
    afines se pueden representar muy f√°cilmente con matrices, si se
    utilizan coordenadas homog√©neas

    USO DE LAS COORDENADAS HOMOG√âNEAS
    
        SEA (x,y,z) entonces T(x,y,z) = (wx,wy,wz,w) 

        donde ùë§ suele tener un valor de 1 (0 es un punto en el infinito):

            (ùë•, ùë¶, ùëß, 1)

    Las matrices de coordenadas homogeneas, optimizan las transformaciones afines.

    La motivacion para estudiar coordenadas homogeneas es que OpenGL internamente
    utiliza este tipo de coordenadas para realizar sus calculos de transformaciones.

TRANSFORMACIONES AFINES CON COORDENADAS HOMOG√âNEAS:

    Dada la transformacion afin:
        
        Y = AX + B

    Las coordenadas homog√©neas permiten representar cualquier transformaci√≥n af√≠n 
    o composici√≥n de transformaciones mediante una sola multiplicaci√≥n de matrices 
    de la forma:

        Y = AX

TRANSFORMACIONES AFINES CON COORDENADAS HOMOG√âNEAS:

    Traslacion:

        A = \begin{pmatrix}
                1 & 0 & 0 & T_x \\
                0 & 1 & 0 & T_y \\
                0 & 0 & 1 & T_z \\
                0 & 0 & 0 &  1  
            \end{pmatrix}
    
    cualquier matriz de transformaci√≥n lineal en tres dimensiones se puede representar en
    coordenadas homog√©neas agreg√°ndole una fila y una columna de 0s, y un 1 como √∫ltimo
    elemento de la diagonal principal. Ejemplo:

        S = \begin{pmatrix}
                    S_x &  0  &  0  \\
                    0   & S_y &  0  \\
                    0   &  0  & S_z
            \end{pmatrix}

        Se convierte en

        S = \begin{pmatrix}
                S_x &  0  &  0  &  0\\
                0   & S_y &  0  &  0\\
                0   &  0  & S_z &  0\\
                0   &  0  &  0  &  1 
            \end{pmatrix}
