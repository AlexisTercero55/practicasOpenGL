9/18/21          alexistercero55@gmail.com
Alexis Tercero: https://github.com/AlexisTercero55

En este repositorio se alojan las practicas OpenGL de la clase de
Graficación por Computadora Grupo:1752-Vargas Castro Daniel (UNAM/MAC).

Mensage de commit: TRANSFORMACIONES AFINES TEORIA.

OpenGL: version 2.1

Caso: GENERACION DE PRIMITIVAS GEOMETRICAS 3D CON OPENGL Y GLUT/FREEGLUT.

Visual Studio Code @\.vscode:
    task.json: Define una tarea de compilacion que se activa con ctrl + shift + b
               ademas manda los binarios a una carpeta especial llamada 'ejecutables'
               que sera ignorada por git mediante .gitignore

               ADVERTENCIAS: En el remoto no se incluye la carpeta 'ejecutables'
                             usted debera crearla para evitar errores en la tarea de compilacion 
                             task.json @ ln: 12
                             o en su defecto modificar el script a sus necesidades.
    
    launch.json: Define la tarea de debugging que se activa con f5.

ARCHIVOS:
    **
    clase.c     Codigo generado a partir de la clase.
    profe.c     CODIGO DE MUESTRA PUBLICADO POR EL PROFESOR Vargas Castro Daniel.

///////////////////////////////////////////////////////////////////////////////////////////////////
9/7/21
-------------------------------------------------------------------------------------
                NOTAS PERSONALES
-------------------------------------------------------------------------------------

Writing an OpenGL Application:
    ENTORNO DE OPENGL EN C/C++
        If you are using C/C++, then you must first set up a build environment 
        (Visual Studio project, GNU makefile, CMake file, etc) that can link to OpenGL.

        Under Windows, you need to statically link to a library called OpenGL32.lib 
        (note that you still link to OpenGL32.lib if you're building a 64-bit executable. 
        The "32" part is meaningless). Visual Studio, and most Windows compilers, 
        come with this library.

    Initialization
        Before you can actually use OpenGL in a program, 
        you must first initialize it. Because OpenGL is platform-independent, 
        there is not a standard way to initialize OpenGL; 
        each platform handles it differently. 
        Non-C/C++ language bindings can also handle these differently.

        There are two phases of OpenGL initialization. 
            The first phase is the creation of an OpenGL Context; 
            the second phase is to load all of the necessary functions to use OpenGL. 
            Some non-C/C++ language bindings merge these into one.
        
        OpenGL Context Creation:
            An OpenGL context represents all of OpenGL. 
            Creating one is very platform-specific, as well as language-binding specific.

    REFERENCIA: https://www.khronos.org/opengl/wiki/Getting_Started (REPASO OBLIGADO)

///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 8/26/21 2D Graficación por Computadora con OpenGL    
-------------------------------------------------------------------------------------
                GENERACIÓN DE PUNTOS, LÍNEAS Y POLÍGONOS
              TEORÍA Y APLICACIÓN CON PRIMITIVAS DE OPENGL
-------------------------------------------------------------------------------------

TIPOS DE DATO DE OpenGL:
    Para mayor portabilidad, OpenGL define sus propios tipos de dato, 
    que en general son compatibles con los tipos estándar del lenguaje C.

    GLboolean   1   GL_TRUE, GL_FALSE
    GLint       32  entero con signo en complemento a 2
    GLfloat     32  IEEE-754
    GLdouble    64  IEEE-754
    GLenum      32  ENUMERACIONES

    https://www.khronos.org/opengl/wiki/OpenGL_Type

ENTORNO DE DIBUJO EN OPENGL:
    glBegin y glEnd delimitan los vértices que definen una primitiva 
    o un grupo de primitivas similares.

    INDICAR A OpenGL EL INICIO DE UN DIBUJO CON PRIMITIVAS:
        void glBeging(GLenum mode);

        glBegin acepta un único argumento que especifica en cuál de las diez formas 
        se interpretan los vértices.

        GLenum mode:
            Especifica la primitiva o primitivas que se crearán a partir de los vértices 
            presentados entre glBegin y el glEnd. EXISTEN 10 MODOS (CONSTANTES SIMBOLICAS)
            
            Tomando 'n' como un número entero que comienza en 1 y 
            'N' como el número total de vértices especificados, 
            las interpretaciones son las siguientes.
            mode :
                GL_POINTS           :   Trata cada vértice como un solo punto. 
                                        El vértice n define el punto n. Se dibujan N puntos.
                GL_LINES            :   Trata cada par de vértices como un segmento de línea independiente. 
                                        Los vértices 2n-1 y 2n definen la línea n. Se dibujan N/2 líneas. 
                GL_LINE_STRIP       :   Dibuja un grupo conectado de segmentos de línea 
                                        desde el primer vértice hasta el último. 
                                        Los vértices n y n + 1 definen la línea n. Se dibujan N - 1 líneas.
                GL_LINE_LOOP        :   Dibuja un grupo conectado de segmentos de línea desde el primer vértice hasta el último 
                                        y luego de regreso al primero. Los vértices n y n + 1 definen la línea n.
                                        Sin embargo, la última línea está definida por los vértices N y 1. Se dibujan N líneas.
                GL_TRIANGLES        :   Trata cada triplete de vértices como un triángulo independiente. 
                                        Los vértices 3n-2, 3n-1 y 3n definen el triángulo n. Se dibujan N/3 triángulos.
                GL_TRIANGLE_STRIP   :   Dibuja un grupo de triángulos conectados. Se define un triángulo para cada vértice 
                                        presentado después de los dos primeros vértices. 
                                        Para n impar, los vértices n, n + 1 y n + 2 definen el triángulo n. 
                                        Para n pares, los vértices n + 1, n y n + 2 definen el triángulo n. 
                                        Se dibujan N - 2 triángulos.
                GL_TRIANGLE_FAN     :   Dibuja un grupo de triángulos conectados. Se define un triángulo para cada vértice 
                                        presentado después de los dos primeros vértices. Los vértices 1, n + 1 y n + 2 
                                        definen el triángulo n. Se dibujan N - 2 triángulos.
                GL_QUADS            :   Trata cada grupo de cuatro vértices como un cuadrilátero independiente. 
                                        Los vértices 4 ⁢ n - 3, 4 ⁢ n - 2, 4 ⁢ n - 1 y 4 ⁢ n definen el cuadrilátero n. 
                                        Se dibujan N 4 cuadriláteros.
                GL_QUAD_STRIP       :   Dibuja un grupo conectado de cuadriláteros. Se define un cuadrilátero para cada par de vértices 
                                        presentado después del primer par. Los vértices 2 ⁢ n - 1, 2 ⁢ n, 2 ⁢ n + 2 y 2 ⁢ n + 1 
                                        definen el cuadrilátero n. Se dibujan N 2 - 1 cuadriláteros. 
                                        Tenga en cuenta que el orden en el que se usan los vértices para construir 
                                        un cuadrilátero a partir de datos de franjas es diferente del que se usa con datos independientes.
                GL_POLYGON          :   Dibuja un único polígono convexo. Los vértices del 1 al N definen este polígono.

            Las líneas, triángulos, cuadriláteros y polígonos que no se especifican por completo 
            no se dibujan

            La especificación mínima de vértices para cada primitiva es la siguiente: 
                1 para un punto, 
                2 para una línea, 
                3 para un triángulo, 
                4 para un cuadrilátero,
                3 para un polígono. 
            Los modos que requieren cierto múltiplo de vértices son: 
                GL_LINES (2), 
                GL_TRIANGLES (3), 
                GL_QUADS (4) y 
                GL_QUAD_STRIP (2).

    INDICAR A OpenGL EL FINAL DE UN DIBUJO CON PRIMITIVAS:
        void glEnd();
    
    INDICAR A OpenGL QUE REALICE LOS DIBUJOS PREVIAMENTE DEFINIDOS ENTRE 
    LAS FUNCIONES glBegin y glEnd, PUEDEN SER VARIOS DIBUJOS:
        void glFinish(void);
    
    BORRAR EL DUBUJO ANTERIOR   <<glClear>>:
        Borrar búferes a valores preestablecidos.

        void glClear(GLbitfield mask);

        GLbitfield mask (indican los búferes que se borrarán):
            GL_COLOR_BUFFER_BIT     :   Indica los búferes actualmente habilitados para la escritura en color.
            GL_DEPTH_BUFFER_BIT     :   Indica el búfer de profundidad.
            GL_ACCUM_BUFFER_BIT     :   Indica el búfer de acumulación.
            GL_STENCIL_BUFFER_BIT   :   Indica el búfer de la plantilla.
        Si no hay un búfer, entonces un glClear dirigido a ese búfer no tiene ningún efecto.

        EJ: glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glClear.xml (LEYENDO REPASO NECESARIO)
    
    ADVERTENCIAS:
        Solo se puede usar un subconjunto de comandos GL entre glBegin y glEnd. 
        Los comandos son: 
            glVertex, 
            glColor, 
            glSecondaryColor, 
            glIndex, 
            glNormal, 
            glFogCoord, 
            glTexCoord, 
            glMultiTexCoord, 
            glVertexAttrib, 
            glEvalCoord, 
            glEvalPoint, 
            glArrayElement, 
            glMaterial y 
            glEdgeFlag. 
        Además, es aceptable usar glCallList o glCallLists para ejecutar listas de visualización 
        que incluyen solo los comandos anteriores. Si se ejecuta cualquier otro comando GL entre glBegin y glEnd, 
        se establece el indicador de error y se ignora el comando.

        OpenGL no tiene forma de saber cuándo debe redibujar 
        los contenidos en la ventana. Para hacer esto, se debe solicitar a GLUT, 
        que ejecute nuevamente la función glutDisplayFunc mediante la función:
            void glutPostRedisplay(void);
        NOTA: ESTO LO HACE EL MANEJADOR DE VENTANS, EN ESTE CASO FREEGLUT.
    
    IMPLEMTACION DE ENTORNO DE DIBUJO OpenGL EN C:
        glBegin(GLenum mode); //DEFINE UN DIBUJO
            /*ponga aqui sus primitivas OpenGL
              No hay límite para el número de vértices que se pueden definir entre glBegin y glEnd.
            */
        glEnd();// TERMINA EL DIBUJO
        glFinish();//ACCION DIBUJAR (PARA OpenGL)

    REFERENCIA:
        https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glBegin.xml (leido hasta errores)

    Si no se define una cámara, cada coordenada puede estar en un rango de [−1, 1].

Colores en primitivas <<glColor>>:
    glColor establece un nuevo color RGBA de cuatro valores.

    Cambiar el color (EXISTEN MAS FUNCIONES):
        void glColor3f(GLfloat red, GLfloat green, GLfloat blue); [0,1]
        void glColor4f(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);

    PRINCIPALES VARIANTES DE glColor:
        glColor3 : RECIBEN 3 PARAMETROS (RGB)
        glColor3 : RECIBEN 4 (RGBA)

        OTRAS QUE RECIBEN EL PUNTERO A UN ARREGLO CON LOS VALORES:
            void glColor4fv(const GLfloat * v);
    
    Associated Gets
    glGet with argument GL_CURRENT_COLOR
    glGet with argument GL_RGBA_MODE

    REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glColor.xml (LEYENDO, REPASO OPCIONAL)

ESTADOS DE OpenGL:  OpenGL FUNCIONA COMO UNA MAQUINA DE ESTADOS. 
    Pasar puntero de funcion con instrucciones de dibujo:
        The new display callback function.

        DEFINICION:
            void glutDisplayFunc(void (*func)(void));

            Establece la devolución de llamada de pantalla para la ventana actual.
    
        DESCRIPCION:
            Cuando GLUT determina que es necesario volver a visualizar el plano normal 
            de la ventana, se llama a la devolución de llamada de visualización de la ventana.

            Antes de la devolución de llamada, la ventana actual se establece en la ventana 
            que debe volver a mostrarse y 
            (si no se registra ninguna devolución de llamada de visualización superpuesta), 
            la capa en uso se establece en el plano normal.

        REFERENCIA: https://www.opengl.org/resources/libraries/glut/spec3/node46.html (LEYENDO : REPASO NESESARIO)

    Indicar que dibuje a OpenGL glFinish:
        glFinish no regresa hasta que se completan los efectos 
        de todos los comandos GL previamente llamados. 
        Dichos efectos incluyen todos los cambios en el estado GL, 
        todos los cambios en el estado de la conexión y 
        todos los cambios en el contenido del búfer de tramas (frame buffer).

        DEFINICION:
            void glFinish(	void);
        
        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glFinish.xhtml

    Indicar al sistema que despliegue.
        Marca la ventana actual que necesita volver a mostrarse.

        DEFINICION:
            void glutPostRedisplay(void);
        
        DESCRIPCION:
            Marque el plano normal de la ventana actual que necesita volver a mostrarse.
            En la siguiente iteración a través de glutMainLoop, se llamará a la devolución 
            de llamada de visualización de la ventana para volver a visualizar el plano 
            normal de la ventana.

            Varias llamadas a glutPostRedisplay antes de la próxima oportunidad de devolución 
            de llamada de pantalla genera solo una única devolución de llamada de visualización. 
            glutPostRedisplay se puede llamar dentro de la pantalla de una ventana o la devolución 
            de llamada de la pantalla superpuesta para volver a marcar esa ventana para volver a 
            mostrarla.
        
        REFERENCIA: https://www.opengl.org/resources/libraries/glut/spec3/node20.html

OBJETOS 2D BASICOS (PRIMITIVAS):
    POLIGONO
    ARISTA
    VERTICE

VERTICES 2D EN OpenGL:
    DEFINICION:
        void glvertex2f(GLfloat, GLfloat);
        Ej: glVertex2f(-0.5, 0.3);

    si no se define una camara, cada coordenada debe estar en [-1,1].

    GLenum mode : GL_POINTS

    Especificar el diámetro de los puntos rasterizados:
        void glPointSize(GLfloat size); // DEFAULT size = 1
    
    IMPLEMENTACION EN C:
        glBegin(GL_POINTS);
            glVertex2f(x1, y1);
            glVertex2f(x2, y2);
            //...
            glVertex2f(xn, yn);
        glEnd();

LINEAS EN OpenGL:   VOID glBeging(GLenum mode);
    GLenum mode
        GL_LINES
        GL_LINE_STRIP
        GL_LINE_LOOP

POLIGONOS EN OpenGL:    VOID glBeging(GLenum mode);
    CONVENCION DE DEFINICION DE VERTICES EN POLIGONOS (CCW)
    CCW : COUNTER CLOCK WISE

    GLenum mode 
        GL_TRIANGLES
        GL_TRIANGLE_STRIP
        GL_TRIANGLE_FAN
        GL_QUADS
        GL_QUAD_STRIP
        GL_POLYGON  :   POLIGONO CONVEXO
///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 8/31/21 Graficación por Computadora con OpenGL 
**DOCUMENTAR EL PIPELINE DE RENDERIZADO Y LAS PROYECCIONES
**DOCUMENTAR glViewport
**VOLUMEN DE RENDERIZADO
---------------------------------------------------------------------------------
            PERCEPCIÓN DE PROFUNDIDAD EN UNA IMAGEN PLANA
    IMPLEMENTACIÓN MEDIANTE CÁMARAS, LUCES Y BUFFERS EN GLUT/FREEGLUT
---------------------------------------------------------------------------------

PERCEPCIÓN DE PROFUNDIDAD:
    Los efectos de profundidad se realizan en los procesos de 
    “Iluminación” y “Proyección” en el paso de “Geometría” del 
    pipeline de renderizado.

    SE NECESITA CONFIGURAR UNA PROYECCION EN PERSPECTIVA
    En la proyección en perspectiva, el volumen de recorte es una
    pirámide trunca (frustum), por lo que los objetos más lejanos a la
    cámara se ven más pequeños en la proyección al plano.

PROYECIONES: 
    Por defecto, OpenGL tiene configurada una matriz para hacer cambios directamente 
    en la escena 3D (mundo), por lo que antes de empezar a configurar la cámara, 
    es necesario avisarle que se harán cambios a la matriz de proyección y cargarle 
    una matriz identidad inicial con las funciones:

    MATRIZ DE PROYECCION:
        void glMatrixMode(GLenum mode);
            
            Especificar qué matriz es la matriz actual.

            PARAMETROS: (GLenum mode)
                Especifica qué pila de matrices es el destino de las operaciones 
                de matriz posteriores. 
                Se aceptan tres valores
                GLenum mode :
                    GL_MODELVIEW, 
                    GL_PROJECTION,
                    GL_TEXTURE. 
                El valor inicial es GL_MODELVIEW. Además, si se admite la extensión 
                ARB_imaging, también se acepta GL_COLOR.
            
            DESCRIPCION:
                glMatrixMode: Establece el modo de matriz actual. 
                              modo puede asumir uno de cuatro valores:

                GL_MODELVIEW
                Aplica las operaciones de matriz subsiguientes a la pila de matrices de modelview.
                    pila de matrices de modelview:
                        MATRIZ DE MODELO : COORDENADAS LOCALES A COORDENADAS DE MUNDO.
                        MATRIZ DE VISTA : ESPACIO A CAMARA

                GL_PROJECTION
                Aplica operaciones de matriz posteriores a la pila de matrices de proyección.

                GL_TEXTURE
                Aplica las operaciones de matriz subsiguientes a la pila de matriz de textura.

                GL_COLOR
                Aplica las operaciones de matriz subsiguientes a la pila de matrices de colores.

                Para averiguar qué pila de matrices es actualmente el objetivo de todas 
                las operaciones de matrices, llame a glGet con el argumento GL_MATRIX_MODE. 
                El valor inicial es GL_MODELVIEW.
                    glGet(GL_MATRIX_MODE);
                
                NOTAS ADICIONALES DE LA PILA DE MATRICES (O VALORES DE GLenum mode):
                    The model, view and projection matrices are three separate matrices. 
                    Model maps from an object's local coordinate space into world space, 
                    view from world space to camera space, projection from camera to screen.
                    
                    If you compose all three, you can use the one result to map all the way 
                    from object space to screen space, making you able to work out what you 
                    need to pass on to the next stage of a programmable pipeline from the 
                    incoming vertex positions.
                    
                    In the fixed functionality pipelines of old, you'd apply model and view together, 
                    then work out lighting using another result derived from them (with some fixes so 
                    that e.g. normals are still unit length even if you've applied some scaling to the 
                    object), then apply projection. You can see that reflected in OpenGL, which never 
                    separates the model and view matrices — keeping them as a single modelview matrix 
                    stack. You therefore also sometimes see that reflected in shaders.
                    
                    So: the composed model view projection matrix is often used by shaders to map from 
                    the vertices you loaded for each model to the screen. It's not required, there are 
                    lots of ways of achieving the same thing, it's just usual because it allows all 
                    possible linear transforms. Because of that, a lesser composed version of it was 
                    also the norm in ye olde fixed pipeline world.

                    REFERENCIA: https://stackoverflow.com/questions/5550620/the-purpose-of-model-view-projection-matrix

            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glMatrixMode.xml (repaso obligado)

        void glLoadIdentity(void);

            Reemplazar la matriz actual con la matriz de identidad.

            glLoadIdentity replaces the current matrix with the identity matrix. 
            It is semantically equivalent to calling glLoadMatrix with the identity matrix
                1 0 0 0 
                0 1 0 0 
                0 0 1 0 
                0 0 0 1
            but in some cases it is more efficient.

            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glLoadIdentity.xml (REPASO OBLIGADO)

    ORTOGONAL:
        ES LA PROYECCION POR DEFECTO.
        SU VOLUMEN DE RECORTE ES UNA CAJA QUE VA  DE -1 A 1.

        CONFIGURACION:
            Multiplicar la matriz actual con una matriz ortográfica.

            void glOrtho(   GLdouble left,
                            GLdouble right,
                            GLdouble bottom,
                            GLdouble top,
                            GLdouble nearVal,
                            GLdouble farVal);
            
            PARAMETROS (VOLUMEN DE RECORTE):
                left, right:
                    Specify the coordinates for the left and right 
                    vertical clipping planes.

                bottom, top
                    Specify the coordinates for the bottom and top 
                    horizontal clipping planes.

                nearVal, farVal
                    Specify the distances to the nearer and farther 
                    depth clipping planes. These values are negative 
                    if the plane is to be behind the viewer.
        
        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glOrtho.xml (REPASO OBLIGATORIO)

    PERSPECTIVA:
        Multiplicar la matriz actual por una matriz de perspectiva

        void glFrustum(	GLdouble left,
                        GLdouble right,
                        GLdouble bottom,
                        GLdouble top,
                        GLdouble nearVal,
                        GLdouble farVal);
        
            PARAMETROS (VOLUMEN DE RECORTE):
                left, right:
                Specify the coordinates for the left and right 
                vertical clipping planes.

                bottom, top
                Specify the coordinates for the bottom and top 
                horizontal clipping planes.

                nearVal, farVal
                Specify the distances to the near and far depth clipping planes. 
                Both distances must be positive.

            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glFrustum.xml (REPASO OBLIGATORIO)

        ADVERTENCIAS: 
            ESPECIFICAR EL VOLUMEN DE RECORTE ES COMPLICADO DADA LA NATURALEZA
            DE SU FORMA (UNA PIRAMIDE TRUNCA), RESULTA DIFICIAL SABER CUAL SERA EL
            RESULTADO AL ESPECIFICAR VALORES A glFrustum.

        USO DE GLU (OPENGL UTILITY) PARA CONFIGURAR LA PROYECCION EN PERSPECTIVA
        DE UNA MANERA MAS SENCILLA.
        CONFIGURACION:
            Configurar una matriz de proyección en perspectiva.

            void gluPerspective(GLdouble fovy,
                                GLdouble aspect,
                                GLdouble zNear,
                                GLdouble zFar);

            PARAMETROS:
                fovy
                Specifies the field of view angle, in degrees, in the y direction.

                aspect
                Specifies the aspect ratio that determines the field of view in the 
                x direction. The aspect ratio is the ratio of x (width) to y (height).

                    Resolución pixeles (ancho × alto)   aspect  Uso
                    640×480 (SD), 800×600,              1.33    Estándar de televisión SD y 
                    1440×1080, 1920×1440                (4:3)   algunos monitores “cuadrados”
                    
                    1280×720 (HD), 1366×768,            1.77    Estándar de televisión actual y
                    1920×1080 (FHD), 3840×2160 (4K)     (16:9)  algunos celulares.
                    
                zNear
                Specifies the distance from the viewer to the near clipping plane 
                (always positive).

                zFar
                Specifies the distance from the viewer to the far clipping plane 
                (always positive).
            
            REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluPerspective.xml (REPASO OBLIGATORIO)

    ADVERTENCIAS:
        SOLO SE LLAMAN LAS FUNCIONES DE PROYECCION CADA CAMBIO DE CAMARA.
            
CAMARA:
    POSICIONAMIENTO CON GLU:
        Definir una transformación de visualización.

        void gluLookAt(	GLdouble eyeX,
                        GLdouble eyeY,
                        GLdouble eyeZ,
                        GLdouble centerX,
                        GLdouble centerY,
                        GLdouble centerZ,
                        GLdouble upX,
                        GLdouble upY,
                        GLdouble upZ);
        
        PARAMETROS: (EN COORDENADAS DE MUNDO)
            eyeX, eyeY, eyeZ
            Specifies the position of the eye point.

            centerX, centerY, centerZ
            Specifies the position of the reference point.

            upX, upY, upZ
            Specifies the direction of the up vector.
        
        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml (REPASO OBLIGATORIO)

ILUMINACION:
    ACTIVAR ILUMINACION:
        habilitar o deshabilitar las capacidades de GL del lado del servidor.

        void glEnable(GLenum cap);

            PARAMETROS: cap
                Especifica una constante simbólica que indica una capacidad GL.

                GL_LIGHTING     //ILUMINACION GENERAL
                    EL VALOR NECESARIO PARA ACTIVAR LA ILUMINACION.

                GL_LIGHTi       //TIPO ESPECIFICO DE ILUMINACION
                    Si está habilitado, incluya la luz i en la evaluación de 
                    la ecuación de iluminación. Consulte glLightModel y glLight.

                    i puede ser cualquier número del 0 al 7, correspondiente al 
                    índice de la luz.
            
            DESCRIPCION:
                glEnable y glDisable habilitan y deshabilitan varias capacidades.
                Utilice glIsEnabled o glGet para determinar la configuración actual 
                de cualquier capacidad. El valor inicial para cada capacidad con la 
                excepción de GL_DITHER y GL_MULTISAMPLE es GL_FALSE.

            REFERENCIA: (REPASO OBLIGADO)

BUFFERS: EFICIENCIA EN RENDERIZADO
    DE COLOR:   ALMACENA LOS COLOERS DE CADA PIXEL.
    DE COLOR DOBLE: FRONTBUFFER, BACKBUFFER.
    DE PROFUNDIDAD: Z-BUFFER CONTIENE LA PROFUNDIDAD DE CADA OBJETO EN LA ESCENA
                    lO QUE NOS PERMITE SABER QUE OBJETOS SE DIBUJAN SOBRE OTROS
                    (ELEGIR QUE RENDERIZAR).

CONFIGURACION DE UNA CAMARA EN PERSPECTIVA CON GLU (#include <GL/glu.h>):
    La siguiente función configura una proyección en perspectiva con un ángulo de apertura de 45°, 
    una relación de aspecto calculada de acuerdo al tamaño de la ventana y 
    planos de corte cercano y lejano en 0.1 y 1000, respectivamente. 
    Posteriormente, se coloca una cámara en las coordenadas (0, 0, 10),
    viendo hacia el centro del mundo (0, 0, 0) y sin rotación (up = (0, 1, 0)).

    void camara(void)
    {
        float ancho = GLUT_WINDOW_WIDTH;
        float alto = GLUT_WINDOW_HEIGHT;
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        gluPerspective(45, ancho/alto, 0.1, 1000);
        gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
    }

    Solo se configura la camara en cada cambio de camara

CONFIGURACION DE BUFFERS DE GLUT/FREEGLUT:

    INICIALIZAR UNA VENTANA CON BUFFERS
    void glutInitDisplayMode(unsigned int mode);

        establece el modo de visualización inicial.

        unsigned int mode:
            Modo de visualización, normalmente la operación OR bit a bit 
            de las máscaras de bits del modo de visualización GLUT. 
            Consulte los valores a continuación

            GLUT_RGBA
            GLUT_DOUBLE
            GLUT_DEPTH
    
    REFERENCIA: https://www.opengl.org/resources/libraries/glut/spec3/node12.html (REPASO OBLIGADO**)

habilitar o deshabilitar las capacidades de GL del lado del servidor.

    void glEnable(GLenum cap);

        PARAMETROS: cap
            Especifica una constante simbólica que indica una capacidad GL.

            EL VALOR NECESARIO PARA ACTIVAR LA ILUMINACION ES: GL_LIGHTING.
        
        DESCRIPCION:
            glEnable y glDisable habilitan y deshabilitan varias capacidades.
            Utilice glIsEnabled o glGet para determinar la configuración actual 
            de cualquier capacidad. El valor inicial para cada capacidad con la 
            excepción de GL_DITHER y GL_MULTISAMPLE es GL_FALSE.

        REFERENCIA: https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/glEnable.xml (REPASO OBLIGADO)

///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 9/2/21 Graficación por Computadora con OpenGL 
**DOCUMENTAR ARCHIVOS .OBJ
---------------------------------------------------------------------------------
                            OBJETOS 3D
             GENERACIÓN DE MALLAS POLIGONALES CON OPENGL
---------------------------------------------------------------------------------

MALLAS:
    ES UNA COLECCION DE (COMPONENTES DE UNA MALLA) 
        VERTICES
        ARISTAS
        POLIGONOS
    QUE DEFINEN UN POLIEDRO.

    PARA REPRESENTAR UN OBJETO EN 3D SE HACE USO DE LA
    DISCRETIZACION MEDIANTE MALLAS POLIGONALES.

    GEOMETRIA:
        DEFINE COMO SE CONECTAN SUS COMPONENTES ENTRE SI.
        GENERALMENTE SOLO DEFINEN LA SUPERFICIE DE LOS OBJETOS.
    
    TIPOS:
        EN RENDERIZADO : MALLLAS DE TIANGULOS (TRIS).
        EN ANIMACION Y MODELADO 3D : MALLAS DE CUADRILATEROS (QUADS).

        Comúnmente se utilizan mallas que combinan triángulos y cuadriláteros.

    ADVERTENCIA:
        Por convención, un polígono se define indicando
        sus vértices en sentido contrario a las manecillas
        del reloj (Counter-Clock Wise o CCW), lo cual
        permite definir su cara frontal.

3D EN OPENGL:
    Las primitivas de OpenGL son objetos 1D y 2D que sirven para representar 
    puntos, líneas y polígonos en un espacio 2D o 3D.

    ESPECIFICAR UN VERTICE (EN COORDENADAS DE MUNDO):
        void glVertex3f(GLfloat x, GLfloat y, GLfloat z);
    
    EJEMP: Definir un plano normal al eje 𝑦 con lados de longitud L
        void plano_xz(GLfloat L) 
        {
            glBegin(GL_QUADS);
                glVertex3f(-L/2, 0, L/2);
                glVertex3f(L/2, 0, L/2);
                glVertex3f(L/2, 0, -L/2);
                glVertex3f(-L/2, 0, -L/2);
            glEnd();
        }

PRIMITIVAS GEOMETRICAS 3D CON GLUT EN MODO SOLIDO Y WIREFRAME:
    CUBO
        void glutSolidCube(GLdouble size);
        void glutWireCube(GLdouble size);
    ESFERA
        void glutSolidSphere(GLdouble radius, GLint slices, GLint stacks);
        void glutWireSphere(GLdouble radius, GLint slices, GLint stacks);
    CONO
        void glutSolidCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
        void glutWireCone(GLdouble base, GLdouble height, GLint slices, GLint stacks);
    TORO
        void glutSolidTorus(GLdouble innerRadius, 
                            GLdouble outerRadius,
                            GLint nsides, 
                            GLint rings);
        void glutWireTorus(GLdouble innerRadius, 
                           GLdouble outerRadius,
                           GLint nsides, 
                           GLint rings);

GLU Models, otras primitivas de Glut:
    GLU provides so called Quadrics objects:
        disk
        partial disk
        sphere
        cylinder
    
    gluCylinder
        Three steps to create a cylinder:
            1. Create a GLU quadric object
                GLUquadricObj *p = gluNewQuadric();
            2. Set to wire frame mode
                gluQuadricDrawStyle(p,GLU__LINE); //o GLU_FILL 
                ADVERTENCIA: **la presentacion no indica p
            3. Derive a cylinder object from p
                gluCylinder(p, base, top, height, slice, stacks);

    REFERENCIA: 
        https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluCylinder.xml
        http://www.csc.villanova.edu/~mdamian/Past/graphicsfa10/notes/HierarchyHand.pdf
        https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluQuadricDrawStyle.xml

DISCRETIZACION DE UNA ESFERA:
    SE DISCRETIZA EN BASE A SUS  PARAMETROS: 
        RADIO
        NUMERO DE PARALELOS  (stacks)
        NUMERO DE MERIDIANOS (slices)
    
    ECUACIONES PARAMETRICAS DE UNA ESFERA
        x_i = (r \cos(\phi_i))\cos\theta_i
        y_i = (r \cos(\phi_i))\sin\theta_i
        x_i = r\sin\theta_i

        \theta_i es el angulo de meridiano y \phi_i el angulo del
        paralelo deseado, discretizados mediante las ecuaciones:
            \theta_i = 2\pi\frac{slice_i}{nSlices}
            \phi = 2\pi\frac{stack_i}{nStacks}  **cambiar a español

DISCRETIZACION DE UN CONO:
    SE DISCRETIZA EN BASE A SUS  PARAMETROS:
        ALTURA h
        RADIO r
        NUMERO DE VERTICES QUE FORMAN LA BASE n
    
    Las coordenadas de un vertice en el circulo que forma la base:
        x_i = r\cos\theta_i
        y_i = r\sen\theta_i
        z_i = -\frac{h}{2}

        donde   \theta_i = 2\pi\frac{i}{n}

    EL VERTICE DE CONVERGENCIA DE TODAS LAS CARAS DEL CONO ES (0,0,\frac{h}{2})

DISCRETIZACION DE UN CILINDRO:
    SE DISCRETIZA EN BASE A SUS PARAMETROS:
        ALTURA h
        RADIO r
        CANTIDAD DE VERTICES EN AMBAS BASES
    
    Las coordenadas de un vertice en el circulo que forman las bases:
        x_i = r\cos\theta_i
        y_i = r\sen\theta_i
        z_i = \pm\frac{h}{2}

        donde   \theta_i = 2\pi\frac{i}{n}

DISCRETIZACIÓN DE UN TOROIDE
    SE DISCRETIZA EN BASE A SUS PARAMETROS:
        RADIO MEOR r
        RADIO MAYOR R
        NUMERO DE ANILLOS n
    
    veritce en su superficie:
        x_i = (R + r\cos\alpha_i)\cos\beta_i
        y_i = (R + r\cos\alpha_i)\sen\beta_i
        z_i = r\sin\alpha_i

///////////////////////////////////////////////////////////////////////////////////////////////////
CLASE 9/7/21 Graficación por Computadora con OpenGL <<terminar apuntes de presentacion antes del commit>>
**actual commit 
**como sustituyen las operaciones con coordenadas homogeneas a las transformaciones afines?
**https://www.youtube.com/watch?v=WDIkqP4JbkE
---------------------------------------------------------------------------------
                   TRANSFORMACIONES GEOMETRICAS
TRANSFORMACIONES AFINES: TRASLACION, ROTACION, ESCALAMIENTO, SESGO Y REFLEXION
---------------------------------------------------------------------------------

TRANSFORMACIONES:
    DAR SENSACION DE MOVIMIENTO.

    TRANSFORMACION AFIN (ALGEBRA LINEAL):
        Una transformación afín en un espacio euclídeo (R^2,R^3) es una transformación que 
        preserva:
            la colinealidad, 
            la coplanaridad 
            las razones de las distancias entre puntos a lo largo de una línea.

        Pragmáticamente, consisten en una transformación lineal seguida de una traslación 
        y se suele representar de la siguiente forma:

            T:X\to AX + B

            Y = AX + B

            donde:
                Y : el punto mapeado en el nuevo conjunto.
                X : el punto original que se desea mapear.
                A : una matriz de transformación.
                B : un vector de traslación

    CONVENCIONES:
        LOS VERTICES SE ENTINDEN COMO VECTORES COLUMNA.

TRANSFORMACIONES AFINES:
    TRASLACION:
        Y = X + B
    
    ROTACION:
        ES cambio de orientación de un cuerpo o un sistema de referencia
        de forma que una línea, llamada eje de rotación, permanece fijo.

        2D:
            R(\theta) = \begin{pmatrix}
                            \cos\theta & -\sin\theta\\
                            \sin\theta & \cos\theta
                        \end{pmatrix}

            DONDE \theta es el ángulo en grados en que se desea rotar el plano.
        
        3D: (Es necesario especificar el eje de rotación)
            R_x(\theta) = \begin{pmatrix}
                            1 &      0     &    0       \\
                            0 & \cos\theta & -\sin\theta\\
                            0 & \sin\theta & \cos\theta
                          \end{pmatrix}

            R_y(\theta) = \begin{pmatrix}
                            \cos\theta  & 0 & \sin\theta \\
                                0       & 1 &    0       \\
                            -\sin\theta & 0 & \cos\theta
                          \end{pmatrix}
            
            R_z(\theta) = \begin{pmatrix}
                            \cos\theta & -\sin\theta & 0 \\
                            \sin\theta &  \cos\theta & 0 \\
                                0      &        0    & 1
                          \end{pmatrix}
    
    ESCALAMIENTO:
        Es el incremento o disminución del tamaño de un cuerpo.

        2D:
            S = \begin{pmatrix}
                    S_x &  0\\
                     0  & S_y
                \end{pmatrix}
        
        3D:
            S = \begin{pmatrix}
                    S_x &  0  &  0  \\
                     0  & S_y &  0  \\
                     0  &  0  & S_z
                \end{pmatrix}

    REFLEXION:
        2D:
            La reflexión en 2D desplaza cada punto de un cuerpo usando una línea de reflexión,
            tal que cada nuevo punto está a la misma distancia de dicha línea 
            con respecto al punto original.

            La matriz de reflexión sobre una línea arbitraria en la forma 𝑦 = 𝑚𝑥 es:

                Ref = \frac{1}{1 + m^2}\begin{pmatrix}
                                            1 - m^2 & 2m  \\
                                              2m    & m^2
                                       \end{pmatrix}
            
            De lo anterior se deduce que la reflexión sobre los ejes x y y,
            se representan mediante las siguientes matrices:

                Ref_x = \begin{pmatrix}
                            1 &  0 \\
                            0 & -1
                        \end{pmatrix}
                
                Ref_y = \begin{pmatrix}
                            -1 & 0 \\
                             0 & 1
                        \end{pmatrix}
        
        3D:
            La reflexión en 3D desplaza cada punto de un cuerpo usando un plano de reflexión,
            tal que cada nuevo punto está a la misma distancia de dicho plano 
            con respecto al punto original.

            La matriz de reflexión para cualquier plano que pasa por el origen,
            con una normal unitaria 𝑁 = (𝑎, 𝑏, 𝑐) es:

                Ref = \begin{pmatrix}
                        1 - 2a^2 &  -2ab    &  -2ac \\
                          -2ab   & 1 - 2b^2 &  -2bc \\
                          -2ac   &  -2bc    & 1 - 2c^2
                      \end{pmatrix}
            
            De lo anterior se deduce que la reflexión sobre los planos xy, yz y el xz, 
            se representan mediante las siguientes matrices.

                Ref_xy = \begin{pmatrix}
                           1 & 0 & 0 \\
                           0 & 1 & 0 \\
                           0 & 0 & -1
                         \end{pmatrix}
                
                Ref_yz = \begin{pmatrix}
                           -1 & 0 & 0 \\
                           0 & 1 & 0 \\
                           0 & 0 & 1
                         \end{pmatrix}
                
                Ref_xz = \begin{pmatrix}
                           1 & 0 & 0 \\
                           0 & -1 & 0 \\
                           0 &  0& 1
                         \end{pmatrix}

COMPOSICIÓN DE TRANSFORMACIONES AFINES:
    Es la aplicación de una serie de transformaciones una detrás de otra. 
    Esto se suele representar mediante ecuaciones del tipo:

        Y = A_1A_2\dots A_n + B_1 + \dots + B_n

        ¡Recuerda que la multiplicación de matrices no es conmutativa!

COORDENADAS HOMOGENEAS (GEOMETRIA PROYECTIVA):
    Este sistema de coordenadas permite ampliar un espacio
    euclídeo de dimensión 𝑛 a un espacio proyectivo de dimensión 𝑛 + 1. 
        
        T: R^n + R^(n+1)

        Esta nueva dimensión representa un punto en el infinito
        donde las línea paralelas se intersecan, dando una ilusión de perspectiva.
    
    Debido a sus propiedades matemáticas, las transformaciones
    afines se pueden representar muy fácilmente con matrices, si se
    utilizan coordenadas homogéneas

    USO DE LAS COORDENADAS HOMOGÉNEAS
    
        SEA (x,y,z) entonces T(x,y,z) = (wx,wy,wz,w) 

        donde 𝑤 suele tener un valor de 1 (0 es un punto en el infinito):

            (𝑥, 𝑦, 𝑧, 1)

    Las matrices de coordenadas homogeneas, optimizan las transformaciones afines.

    La motivacion para estudiar coordenadas homogeneas es que OpenGL internamente
    utiliza este tipo de coordenadas para realizar sus calculos de transformaciones.

TRANSFORMACIONES AFINES CON COORDENADAS HOMOGÉNEAS:

    Dada la transformacion afin:
        
        Y = AX + B

    Las coordenadas homogéneas permiten representar cualquier transformación afín 
    o composición de transformaciones mediante una sola multiplicación de matrices 
    de la forma:

        Y = AX

TRANSFORMACIONES AFINES CON COORDENADAS HOMOGÉNEAS:

    Traslacion:

        A = \begin{pmatrix}
                1 & 0 & 0 & T_x \\
                0 & 1 & 0 & T_y \\
                0 & 0 & 1 & T_z \\
                0 & 0 & 0 &  1  
            \end{pmatrix}
    
    cualquier matriz de transformación lineal en tres dimensiones se puede representar en
    coordenadas homogéneas agregándole una fila y una columna de 0s, y un 1 como último
    elemento de la diagonal principal. Ejemplo:

        S = \begin{pmatrix}
                    S_x &  0  &  0  \\
                    0   & S_y &  0  \\
                    0   &  0  & S_z
            \end{pmatrix}

        Se convierte en

        S = \begin{pmatrix}
                S_x &  0  &  0  &  0\\
                0   & S_y &  0  &  0\\
                0   &  0  & S_z &  0\\
                0   &  0  &  0  &  1 
            \end{pmatrix}
